# JAVA 

* IDE : IntelliJ IDEA 2020.2.1

- [JAVA](#java)
  - [Java](#java-1)
  - [변수](#변수)
  - [배열](#배열)
    - [참고](#참고)
  

**자바 실행 과정**   
![실행과정](../Java/img/compile.jpg)   
운영체제에 상관없이 바이트 코드 파일은 JVM을 통해서 실행 가능한 기계어로 번역된다.

**패키지**   
자바는 소스 파일 및 컴파일된 바이트 코드 파일들을 기능별로 쉽게 관리하기 위해 패키지를 사용한다. JDK 11 이후 버전부터는 직접 생성하는 프로젝트도 모듈로 활용할 수 있기 때문에 반드시 패키지를 요구한다. JDK 8 이전 버전에선 필수는 아니지만 JDK 버전에 상관없이 패키지 만드는 것이 좋다.

**JAVA Memory 구조?**
- class area, stack, heap

**IntelliJ 단축키**

psvm + TAB : public static void main() 함수 생성

## Java
* 자바의 장점
  * 운영체제에 독립적이다.
    * 자바 응용 프로그램은 JVM (Java Virtual Machine)하고만 통신을 하고 JVM이 운영체제가 이해할 수 있도록 응용 프로그램을 변환하여 전달한다. JVM은 운영체제에 종속적이다.
  * 객체지향언어
    * OOP(Object-Oriented Programming language)중 하나로 객제지향의 특징인 상속, 캡슐화, 다형성이 잘 적용된 순수 객체지향언어라는 평가를 받고있다.
  * 쉬운 난이도
    * OOP 관련 구문은 스몰톡(small talk)이라는 객체지향언어에서 가져왔고, 연산자와 기본구문은 C++에서 가져왔다고 한다. 장점은 취하고 복잡한 부분(메모리 관리)을 제거해 단순화 했다.
  * 자동 메모리 관리 (Garbage Collection)
    * GC가 자동적으로 메모리를 관리해주기 때문에 개발자는 메모리를 따로 관리 하지 않아도 된다.
  * 네트워크와 분산처리를 지원한다.
    * 다양한 네트워크 프로그래밍 라이브러리 (Java API)가 존재한다.
  * 멀티스레드를 지원한다.
    * 멀티 스레딩 프로그램은 OS마다 구현방법이 다르지만 JAVA에서는 시스템과 관계없이 구현 가능하다 (JVM), 여러 스레드에 대한 스케쥴링은 **자바 인터프리터**가 담당한다.
  * 동적 로딩(Dynamic Loading)을 지원
    * 실행시 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용할 수 있다. 그래서 일부 클래스가 변경되어도 응용 프로그램 전체를 다시 컴파일 하지 않아도 된다.
    * 단점으로는 속도 문제가 대표적인데 JVM과 동적 로딩 방법때문에 속도가 느린것으로 추정한다. 이에 대한 대안으로 **JIT컴파일러**와 **Hotspot**같은 신기술의 도입으로 JVM 기능을 향상시켜 속도 문제를 개선했다고 한다.

* Java 실행 과정
  ```
    1. 프로그램의 실행에 필요한 클래스(*.class)파일을 로드한다.
    2. 클래스 파일을 검사한다. (파일 형식, 악성 코드 확인)
    3. 지정된 클래스에서 main(String[] args)를 호출한다.
  ```

## 변수
  * 기본형 (Primitive type) : boolean, char, byte, short, int, long, float, double   
  
    |자료형|크기|저장 가능한 범위|종류|
    |--|--|:--:|:--:|
    |boolean|1byte| true, false| 논리형
    |byte|1byte|-128 ~ 127|정수형
    |short|2byte|-32.768 ~ 32,767|정수형
    |char|2byte|0 ~ 65536 |문자형
    |int|4byte|-2,147,483,648 ~ 2,147,483,647|정수형
    |float|4byte|1.4E-45 ~ 3.4028235E38|실수형
    |long|8byte|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,77,807|정수형
    |double|8byte|4.9E-324 ~ 1.7976931348623157E308|실수형   
    * C/C++ 에서 char은 1byte (ASCII)였다. 하지만 JAVA의 char은 2byte (UNICODE)라는 차이가 있다. JAVA의 char의 범위는 C/C++의 unsigned short 와 같다.
    * JVM은 피연산자를 4byte단위로 저장하기 때문에 크기가 4byte보다 작은 자료형들 (byte, short)을 연산할 때는 int를 사용하는 것이 효율적이다.


  * 기본형 - **실수형**
    * float : 1 + 8 + 23 = 32bit = 4byte  
      |부호|지수|가수|
      |:--:|:--:|:--:|
      |1|8|23|
    * double : 1 + 11 + 52 = 64bit = 8byte  
      |부호|지수|가수|
      |:--:|:--:|:--:|
      |1|11|52|
  
  * 참조형 (Reference type) : Primitive type 8개를 제외한 나머지, 객체의 주소를 저장
  * 형 변환 (casting)
    * 자동 형변환 : 캐스트 연산자를 생략한 경우엔 JVM이 자동적으로 형변환 한다. 이때 큰 자료형에서 작은 자료형으로 변환은 값 손실의 우려가 있어 자동 형변환이 적용되지 않는다.
    ![casting](./img/casting.png)
    * 연산에서 형변환은 int보다 작은 경우 int로, int보다 큰 경우 큰 자료형에 맞춰진다.
  * JAVA에서 상수는 final이다. (C++은 const 이다)
## 배열

```
    int[][] arrays;
    int arrays[][];
    intp[] arrays[];
```
* C++과 기본 개념은 같다. 
  
2차원 배열일 때 주소값은 어떻게 될까???

### 참고
* 『혼자 공부하는 자바』신용권저, 한빛미디어 
* 『자바의 정석 2판』 남궁 성저, 도우 출판